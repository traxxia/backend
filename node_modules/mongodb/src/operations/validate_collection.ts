<<<<<<< HEAD
import type { Admin } from '../admin';
import type { Document } from '../bson';
import { MongoRuntimeError } from '../error';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import type { Callback } from '../utils';
import { CommandCallbackOperation, type CommandOperationOptions } from './command';

/** @public */
export interface ValidateCollectionOptions extends CommandOperationOptions {
=======
import { type Connection } from '..';
import type { Admin } from '../admin';
import { type Document } from '../bson';
import { MongoDBResponse } from '../cmap/wire_protocol/responses';
import { MongoUnexpectedServerResponseError } from '../error';
import type { ClientSession } from '../sessions';
import { CommandOperation, type CommandOperationOptions } from './command';

/** @public */
export interface ValidateCollectionOptions extends Omit<CommandOperationOptions, 'rawData'> {
>>>>>>> feat-phase2-refactor
  /** Validates a collection in the background, without interrupting read or write traffic (only in MongoDB 4.4+) */
  background?: boolean;
}

/** @internal */
<<<<<<< HEAD
export class ValidateCollectionOperation extends CommandCallbackOperation<Document> {
  override options: ValidateCollectionOptions;
  collectionName: string;
  command: Document;

  constructor(admin: Admin, collectionName: string, options: ValidateCollectionOptions) {
    // Decorate command with extra options
    const command: Document = { validate: collectionName };
    const keys = Object.keys(options);
    for (let i = 0; i < keys.length; i++) {
      if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== 'session') {
        command[keys[i]] = (options as Document)[keys[i]];
      }
    }

    super(admin.s.db, options);
    this.options = options;
    this.command = command;
    this.collectionName = collectionName;
  }

  override executeCallback(
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<Document>
  ): void {
    const collectionName = this.collectionName;

    super.executeCommandCallback(server, session, this.command, (err, doc) => {
      if (err != null) return callback(err);

      // TODO(NODE-3483): Replace these with MongoUnexpectedServerResponseError
      if (doc.ok === 0) return callback(new MongoRuntimeError('Error with validate command'));
      if (doc.result != null && typeof doc.result !== 'string')
        return callback(new MongoRuntimeError('Error with validation data'));
      if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
        return callback(new MongoRuntimeError(`Invalid collection ${collectionName}`));
      if (doc.valid != null && !doc.valid)
        return callback(new MongoRuntimeError(`Invalid collection ${collectionName}`));

      return callback(undefined, doc);
    });
=======
export class ValidateCollectionOperation extends CommandOperation<Document> {
  override SERVER_COMMAND_RESPONSE_TYPE = MongoDBResponse;
  override options: ValidateCollectionOptions;
  collectionName: string;

  constructor(admin: Admin, collectionName: string, options: ValidateCollectionOptions) {
    super(admin.s.db, options);
    this.options = options;
    this.collectionName = collectionName;
  }

  override get commandName() {
    return 'validate' as const;
  }

  override buildCommandDocument(_connection: Connection, _session?: ClientSession): Document {
    // Decorate command with extra options
    return {
      validate: this.collectionName,
      ...Object.fromEntries(Object.entries(this.options).filter(entry => entry[0] !== 'session'))
    };
  }

  override handleOk(response: InstanceType<typeof this.SERVER_COMMAND_RESPONSE_TYPE>): Document {
    const result = super.handleOk(response);
    if (result.result != null && typeof result.result !== 'string')
      throw new MongoUnexpectedServerResponseError('Error with validation data');
    if (result.result != null && result.result.match(/exception|corrupt/) != null)
      throw new MongoUnexpectedServerResponseError(`Invalid collection ${this.collectionName}`);
    if (result.valid != null && !result.valid)
      throw new MongoUnexpectedServerResponseError(`Invalid collection ${this.collectionName}`);

    return response;
>>>>>>> feat-phase2-refactor
  }
}
